\section{Противодействие honeypots.}
\label{honeypot_section}
\label{honeypot_section_page}

Помимо классификации honeypot по типу работы (см. \ref{honeypots_in_general} на стр. \pageref{honeypots_in_general} ) следует различать хонипоты по тому кто и для чего их использует.
Хонипоты устанавливаются следующими типами организаций и людей:

\begin{enumerate}
\item{Организации цель которых - противодействие вредоносному ПО}
\item{Любители/отдельные исследователи}
\item{Организации использующие honeypots для защиты корпоративной сети}
\end{enumerate}

Первые два типа хонипотов наиболее опасны для владельца ботнета, поскольку их цели чаще всего включают выявление алгоритмов работы закладок и ботнетов вцелом.\\
Последний вариант зачастую служит лишь для индикации проникновения, когда хонипот сигнализирует
 владельцам сети о том, что в ней завелся нежелательный элемент (программа-бот или человек).
 В том числе такие хонипоты могут использовать псевдо-аккаунты в различных instant messaging
 сетях (включая внутре-корпоративную) для регистрации ссылок на вредоносный контент (так, например,
ловятся авторассылки заражёнными хостами линков на дропперы).


\subsection{Общие замечания.}

Противодействие honeypots с существенным успехом возможно только при
взаимодействии с внешним по отношению к honeypot ресурсом. Дело здесь, в
первую очередь, в том, что honeypot, направленный на выявление закладок,
может быть абсолютно прозрачен, т.е. может использовать сетевой метод
выявления закладок и offline'овый метод их анализа. Разумеется в случае
offline'овых средств исследования защититься практически невозможно.
Конечно можно использовать шифрование, однако ключ расшифрования
придётся хранить на машине, на которой исполняется программа. Даже в
случае, если ключ расшифрования берется из сети и производится
зашифрование/расшифрование  при исполнении программы (<<на лету>>), это
всего лишь усложнит задачу, поскольку существуют методы получения
слепков памяти ОС - от стандартного для windows режима
hibernate\footnote{имеется ввиду  режим при котором ОС сохраняет
содержимое памяти на диск, затем выключается. При следующей загрузке ОС
восстанавливает свое состояние, включая внешний вид и набор запущенных
программ} до получения слепков состояний работы ОС целиком если она
загружена внутри виртуальной машины.

\subsubsection{Возможности}

Резюмируя вышесказанное,  можно сказать, что противодействие honeypots
 можно разбить на следующие направления:

\begin{itemize}
\item{регистрация известных honeypots на управляющем сервере}
\item{максимальное усложнение процесса реверсинга}
\item{протокол работы с одновременными двусторонними проверками}
\item{противодействие дизассемблированию}
\item{аккуратная работа с LAN}
\item{аккуратная рассылка линков на дропперы}
\end{itemize}

\paragraph{регистрация известных honeypots на управляющем сервере}
часть IP ханипотов можно выявить через публичные services - часть проектов предоставляют free services for malware checks. Также после определенного количества ошибок коммуникации отдельно взятый бот должен признаваться хонипотом и отрабатываться отдельно, в т.ч. с записью в базу как минимум IP.

\paragraph{максимальное усложнение процесса реверсинга}
 для того чтобы сделать его слишком дорогим для рядовых исследователей
 держателей хонипотов.

\paragraph{протокол работы с одновременным двусторонними проверками\\}
Подразумевает разделение протокола работы закладка-сервер на взаимодополняющие части, одновременную эмуляцию которых на одной стороне реализовать невозможно либо крайне трудно.

\paragraph{аккуратная работа с LAN\\}
Один из вариантов распространения внутри LAN - атаковать только хосты которые уже инициализировали трафик к зраженному, либо хосты к которым заражённый хост соединялся,
т.е. отказ от активности типа сканирования сети для распространения. Это позволит избежать
 детектирования с использованием darknet (см. \ref{darknet}, стр. \pageref{darknet}).

\paragraph{аккуратная рассылка линков на дропперы\\}
Использование рассылки через сети instant messaging ссылок на сайты с дропперами возможно, но при этом
стоит продумать схему так, чтобы не <<засветить>> заражение. Очевидно, что массовый icq/jabber/whatever
spam  будет замечен довольно быстро самим пользователем по жалобам из списка его контактов, кроме того, в случае корпоративной сети возможно попадание хоста в списки машин выяленных IDS/honeypot как зараженные.

\subsubsection{Выявление}

\paragraph{Обзор методики\\}

Выявление хонипотов можно построить, во первых, на проверке ошибок в их
конфигурации, когда хонипот имеет существенные отличия от нормальной
машины по  установленному на нем софту и железу. Эти несоответствия
возможны у неряшливо построенных ловушек, т.е.  в случае если хонипот
примитивный. Во вторых, со стороны сервера можно регистрировать
настораживающие события, например, уход в offline'овое состояние на
несколько дней и более сразу после начала тестового периода\footnote{о
тестовом периоде ниже, см. \ref{test_period} на странице
\pageref{test_period}.}

\subsection{Особенности honeypots}

Характеристики хонипотов можно разделить на безусловные и возможные.

\paragraph{Безусловные:\\}


\begin{itemize}
\item{Ограничение доступа в сеть для закладки.}
\item{Ограниченность комплектующих и соответственно парка компьютеров
используемых как ловушки.}
\end{itemize}

\paragraph{Возможные:\\}

\begin{itemize}
\item{Атипичная конфигурация софта.}
\item{Атипичная конфигурация железа.}
\item{Работа ОС honeypotа в виртуальной машине}
\item{работа honeypot как usermode или kernelmode rootkit}
\end{itemize}

\subparagraph{работа honeypot как usermode или kernelmode rootkit} - наличие перехватов системных таблиц и usermode rootkit - тоже возможно ханипот.


\subsubsection{Блокировка части алгоритмов работы закладки}

Невозможность коммуникации с драйвером/модулем процедура инсталяции которого вернула success - один из признаков сандбокса.


\subsubsection{Блокировка доступа к сети}

Блокируют на хонипотах заражённую машину обычно либо сразу по проявлению
от неё подозрительного трафика,  либо, что реже, это  происходит через
одну-две недели после того как наличие закладки было выявлено по
создаваемому ей подозрительному трафику. Эта особенность объясняется
тем,  что по законодательству многих стран на деструктивные действия
производимые с его сетевых адресов на  владельца хонипота могут подать
иск в суд, причем заведомо выигрывая его, поскольку владельцу хонипота
сложно будет доказать, что он не знал о деструктивном характере трафика
закладки, равно как и то что он  не мог его заблокировать. Срок в,
минимум, две недели объясняется тем, что  немногие владельцы хонипотов
могут позволить себе ждать проявления активности более длительное время.

\paragraph{Факт обращения в сеть},
это очевидно, регистрируется даже если трафик шифруется и, пусть даже
расшифровать его не представляется возможным, но  сам факт обращений в
сеть и их характер могут позволить отследить управляющий сервер (или несколько
серверов, что не принципиально, так как число серверов конечно). Однако
существуют весьма эффективные способы маскировки управляющих серверов -
использование паразитного трафика того же типа (но никому не
предназначенного) и использование средств анонимизации (цепочки анонимных
прокси, специализированные сети анонимизации работы с интернет, например
 TOR network \index{TOR}\index{TOR network}). Также могут быть
использованы способы частичной маскировки, когда при выяснении A-записи
 управляющего сервера выдаются каждый раз разные данные, например за счет
ротации в DNS, либо за счет того, что используется доменное имя
генерируемое по псевдослучайному алгоритму.
Выявление управляющих серверов приведет, рано или поздно, к их закрытию
в силу жалоб владельцев honeypot и пострадавших от деятельности ботнета.

\subparagraph{Однако,}

это ещё не повод отказываться от зашифрования трафика, поскольку оно
существенно усложняет проблему реверсирования алгоритма  работы закладки
и делает необходимым  её дизассемблирование, что
ресурсозатратно - реверсинг вообще времяемкая и отнюдь не
простая процедура. Решение проблемы маскировки сервера будет
рассмотрено ниже.

\subsubsection{Набор железа}

В случае организации  хонипота его владелец явно ограничен доступными
ресурсами - у него не может быть тысячи  материнских плат, процессоров,
видеокарт и прочих железок необходимых для создания компьютера.  Если
закладка за счет неумелого поведения владельцев хонипота сумела
определить что машина, на  которой она установлена является хонипотом,
то в дальнейшем сервер может отрабатывать её по отдельному алгоритму.
Как будет показано далее, это позволит и в дальнейшем выявлять установку
на хонипоты собранные с участием того же железа. Поскольку количество
железа доступного любой конкретной компании ограничено, то хонипоты
будучи пересобраны для другой конфигурации будут, весьма вероятно,
содержать комплектующие от предыдущих сборок\footnote{Не стоит забывать, что у каждой
используемой в компьютере железки есть свой серийный номер доступный для
считывания программным способом.}. Это, в свою очередь, позволяет после
первого обнаружения узнавать о любых других конфигурациях, в которых
используется то же железо.

\subsubsection{Атипичная конфигурация железа}

Атипичность, в данном случае, это, например, мощный современный
процессор, но совсем маленький единственный диск на пару гигабайт и
всего 64 Мб памяти. Возможны другие не менее подозрительные  варианты.
Основной признак нетипичности конфигурации - несоответствие конфигурации
оборудования некоторому эмпирически  известному минимуму для боле-менее
комфортной работы на компьютере с windows данной версии <<на борту>>, а
также несоответствие здравому смыслу. Возвращаясь к вышеописанному
примеру, можно заострить внимание на том, что если у пользователя
нашлись деньги на несколько гигагерцовый Pentium4, то очень странно, что
при этом у него не было денег хотя бы на 256 Мб памяти и современный
жесткий диск в десятки гигабайт .

\subsubsection{Атипичная конфигурация ПО}

Атипичность может, например, состоять в том, что на компьютере,
выглядящем по набору программ так, будто на него только что поставили
ОС, происходит серфиг сети, но длительное время не устанавливается
никакого программного обеспечения. Тут дело в том, что <<голый виндовс>>
практически бесполезен в работе. Можно поверить в то, что пользователь
едва установив ОС сразу полез в сеть и подцепил там закладку. Но очень
маловероятно, что этот пользователь за месяц не поставит ни одной
программы.

\subsubsection{Работа внутри виртуальной машины}

Некоторые хонипоты могут работать внутри виртуальных машин.
Это может показаться очень удобным владельцу хонипота, однако
обнаружение таких хонипотов не составляет труда - в сети присутствуют
примеры исходного кода.


\subsection{Решение.}

\subsubsection{Выявление виртуальных машин}
\label{vm_detection}
В числе прочих проверок необходимо проверять тип машины и, если это
виртуальная машина (например ОС  выполняется внутри {\bfэмулятора}
физической машины, а не на {\bfфизическом} компьютере), то
предусматривать альтернативное исполнение. Причем чтобы не возникало
подозрений и попыток помешать выявлению виртуальной машины ветвление
алгоритма должно происходить на сервере. Реализация выявления
виртуальной машины проста, в сети есть примеры.

Однако часть пользователей использует виртуальные машины с windows в
повседневной работе. Т.е. сам факт работы в виртуальной машине еще не 100\%
доказательство, что это honeypot. Закладка должна хранить данные о своем
состоянии, в частности если закладка в прошлом выполнялась в нормальной
среде, а затем оказалась в виртуальной машине - это скорее всего хонипот
 или среда для проверки вредоносного ПО в антивирусной компании или у
энтузиаста-исследователя, поскольку современные производители виртуальных
 машин не предоставляют возможности загрузки виртуальной машины с физического
 диска\footnote{так, насколько нам известно в vmware и sun virtual box,
ранее в vmware была возможность загрузки с физического диска}.

\subsubsection{противодействие дизассемблированию}
\label{antihoneypot_crypto}
Шифрование блоков закладки. Нет смысла противодействовать на уровне ином как отсутствие ключей
расшифрования у авера, поскольку любой другой способ лишь оттянет получение кода - в рамках общей модели угроз\ref{bot_treat_model}.

\subsubsection{обнаружение работы под отладчиком}
Нет смысла противодействовать отладке, однако ее надо пытаться обнаружить и отрабатывать работу в отладчике отдельно, а именно отрапортовать о хонипоте и не расшифровывать payload.

Из полезных для обнаружения отладки способов можно перечислить следующие:
\begin{enumerate}
\item{Проверка CRC исполняемого кода}
\item{проверка и использование указателя стека}
\item{перехват int1, int3, int0}
\item{использование SEH}
\item{Win32 API IsDebuggerPresent()}
\item{ключи реестра,процессы,семафоры}
\item{использование указателя на стек при расшифровании блоков кода}
\item{расшифрование от конца к началу}
\item{entry point tricks (TLS)}
\end{enumerate}

\paragraph{Проверка CRC исполняемого кода\\}
В x86 архитектуре отладчик в пошаговом режиме использует модификацию исполняемого кода трассируемого приложения вставкой инструкций INT3. Код закладки должен проверять CRC
исполняющихся участков кода и в случае изменения отрабатывать функционал <<работа под отладчиком>>.

\paragraph{проверка указателя стека\\}
Отладчик может хранить данные об отладке в стеке отлаживаемого приложения. Для проверки
запоминаем текущий указатель на стек, кладем в стек любое значение, вынимаем его из стека,
затем сравниваем указатель на стек с сохраненным - если не равно - работа под отладчиком:
\begin{verbatim}
проверка указателя стека:
MOV     BP,SP  ; Let's pick the Stack Pointer
PUSH    AX     ; Let's store any AX mark on the stack
POP     AX     ; Pick the value from the stack
CMP     WORD PTR [BP-2], AX ; Compare against the stack
JNE     DEBUG  ; Debugger detected!
\end{verbatim}
\subparagraph{использование указателя на стек при расшифровании блоков кода} существенно затруднит отладку поскольку int1 использует стек. Т.е. под отладчиком блок не будет
расшифрован.

\paragraph{перехват int1, int3, int0\\}
Прерывания int1 и int3 используются отладчиками. Перехваченные прерывания можно использовать для
расшифровки блоков кода, а также для рапорта о хонипоте. Перехват int1 и int3 легко
обходится в отладчиках использующих виртуальные машины, виртуальные машины следует
распозавать отдельно (см. стр. \pageref{vm_detection}). Некоторые отладчики некорректно
отрабатывают перехват int0.

\paragraph{использование SEH\\}

SEH - structured exception handling предоставляет из себя использование блоков типа:
\begin{verbatim}
try {
// код который может вызывать exception
}
catch {
// код который обрабатывает возможные exceptions
}
\end{verbatim}
идея в том, чтобы намеренно создавать исключения в блоке try гарантированно
получая упраление в блоке catch. Есть шанс, что в процессе отладки реверсер может
пропустить часть кода, которая выполняется в обработчике эксцепшена. Т.е. проверки
CRC например можно разместить в блоке catch.

\paragraph{ключи реестра,процессы,семафоры\\}
Отладчиков не так уж и много, соответственно можно обнаруживать соответствующие им ключи реестра, имена процеесов, глобальные системные семафоры и прочие объекты (например имена драйверов). Далее закладка может иметь некий индивидуальный подход к установленному отладчику.Впрочем наличие установленного в системе отладчика еще не говорит о том, что он применяется именно к боту. Наиболее безопасным был бы отказ работы закладки в случае если в системе установлен отладчик, однако таким образом пропускаются компьютеры многих программистов.В зависимости от целей работы данного ботнета можно отрабатыавть ситуацию по разному.

\paragraph{расшифрование от конца к началу\\}
использование процедур расшифрования таким образом чтобы начало расшифровывваемого блока записывалось последним немного улучшает шансы на выполнение части кода без контроля
отладчиком - реверсер не может поставить breakpoint на начало блока до его расшифрования
 - int3 перезапишется данными в процессе расшифрования.

\paragraph{entry point tricks (TLS)\\}
Windows specific: PE формат позволяет использовать более 1й точки входа при запуске -
Thread Local Storage (TLS) позволит выполнить код до основной точки входа.

\subsubsection{Скрытие управляющего сервера}

Как уже указывалось ранее, совершенно очевидно, что  выявить управляющие
сервера можно  по частоте обращений и их характеру. Выход прост:
закладка должна сама серфить сеть в случайном порядке. Таким образом
исключается возможность выяснить управляющий сервер просто анализируя
трафик, без анализа закладки с отладчиком в руках.

\paragraph{Реализация серфинга}
должна быть сделана внимательно, корректным образом, поскольку в случае
ошибок могут возникнуть проблемы со стороны поисковых машин и рядовых
пользователей.

\subparagraph{Во первых,}
 не следует искать случайные наборы символов. Резкое увеличение
поисковых запросов, с мизерным hitrate в поисковом кэше гарантированно
привлечет внимание.

\subparagraph{Во вторых,}

 не стоит только искать - надо <<ходить>> по найденным ссылкам, иначе
возрастет нагрузка на поисковик и сильно изменится статистика наиболее
часто искомых слов, что тоже плохо. Кроме того, если не позаботиться  о
распределении запросов случайным образом, то нагрузка на поисковые
системы также сильно возрастет, что  может привести к незапланированным
отказам в обслуживании, что тем более привлечет внимание.

\subparagraph{В третьих,}
 следует составлять поисковую строку так, чтобы находить достаточное
количество  результатов, то есть не более трех-пяти слов в запросе,
количество должно меняться от запроса к запросу.

\paragraph{Инициализация серфинга}

возможна списком поисковых машин (google, yandex, rambler, yahoo и
другие ), а набор слов для поиска закладка  может брать из файлов
носителя либо из собственного словаря в случайном порядке.


\subsubsection{Инкубационный период}
\label{incubation_period}
Пользуясь природными аналогиями можно вспомнить, что у многих
заболеваний есть инкубационный период, когда анализы не дают возможности
установить факт заболевания. С целью скрытия rootkits от владельцев
хонипотов следует прибегнуть к тому же средству: в момент инсталляции
закладка может не проявлять вообще никакой сетевой активности.

Так же актуально наличие паузы в несколько минут перед тем, как закладка
 прописывает себя на диск - часть хонипотов используют раннее обнаружение -
через несколько секунд (или минут) делается холодная перезагрузка хонипота,
после чего используются методы offline анализа.

Большой инкубационный период нужен для того чтобы, во первых, обойти
краткосрочные проверки на очень многих honeypots.

Инкубационный период, равный месяцу, а тем более двум,  позволит
избежать выявления закладки во многих интерактивных хонипотах.

Также возможно деление инкубационного периода на стадии - например:
\begin{enumerate}
 \item {пауза от начала выполнения - никакой активности }
 \item {пауза перед инсталляцией в автозапуск на диск - сбор информации о системе,
тесты на хонипот без участия сервера}
 \item {регистрация на сервере с отправкой информации о системе}
 \item {двусторонние тесты (участвуют и сервер и бот) на хонипот и отладку}
\end{enumerate}


\paragraph{Учет возможности переустановки времени}

на компьютере является необходимым условием соблюдения сроков
инкубационного периода. При установке закладки она должна запомнить
текущее время на компьютере, плюс сохранять локальное время при каждой
загрузке компьютера. Подозрительными являются скачки времени между
перезагрузками компьютера более чем в трое суток. В таких случаях
закладка должна зафиксировать это и, возможно, отреагировать какими либо
действиями.

Сервер должен иметь возможность выдать клиенту текущее время,  равно как и клиент серверу. Закладка таким образом может детектить сетевой honeypot за счет выявления разницы между данными полученными по NNTP и по скрытому каналу от сервера. Сервер может сопоставлять
время на боте с прочими параметрами отрапортованными им выявляя реверсера.

Например, если скачки времени вперед на существенную величину
производятся постоянно (например, более нескольких раз
подряд за короткий срок\footnote{<<несколько>> и <<подряд>> - существенные факторы в том
смысле, что бывает, что люди переустанавливают время на компьютере чтобы
обмануть регистрационную программу устанавливаемого платного ПО. Однако не стоит
забывать, что человеку свойственно бывать в отпусках, так что выключение компьютера
может оказаться вполне нормальным}), также нормальными являются скачки если используется компьютер с несколькими ОС - есть шанс, что пользователь все это время работал в другой ОС. Однако скачки времени вперед будут однозначно характеризовать хост как нетипичный если реальное время (полученное по NTP и от управляющего сервера) существенно отличается.\\

При наличии доступа в сеть закладка может отрапортовать конфигурацию железа,
которое с большой вероятностью является honeypot'ом. Проверка
времени по NTP может не дать достоверных результатов, так как обращения
по NNTP и другим стандартным протоколам могут перенаправляться и модифицироваться.
 Так,  например, CWSandbox\index{CWSandbox} умеет сэмулировать отправку по SMTP
 не отправляя данных вовне, а лишь представляясь удаленной системой.

\subsubsection{Тестовый период}
\label{test_period}

После окончания инкубационного периода закладка должна пройти тестовый
период.

Во время работы в тестовом режиме закладка   должна серфить сеть также
как и в рабочем, причем не исключая из серфинга списка   контролирующих
серверов\footnote{это  позволит исключить обособление списка управляющих
серверов от прочих, что было бы видно человеку, реверсирующему
закладку}.

\subsubsection{Ступенчатая загрузка}

Чтобы на каждом этапе работы закладки исключить потенциальную
возможность попадания в руки  вероятного противника информации о
структуре закладки необходимо сделать загрузку закладки ступенчатой.

\begin{enumerate}
\item{1-я ступень инсталлируется <<как обычно>> - при входе на заражённый
web server\footnote{либо в индивидуальном порядке человеком временно получившим доступ к атакуемому
 компьютеру - скачиванием и запуском инсталлятора первой ступени, что в других случаях выполняет эксплойт
 к браузеру}. Начинается инкубационный период.}
\item{-я ступень скачивается первой при удачном окончании инкубационного периода. Начинается тестовый период.}
\item{-я ступень скачивается второй при удачном окончании тестового периода. С этого момента можно использовать payload, имея существенную вероятность того, что носитель не является хонипотом.}
\end{enumerate}

\subsubsection{Общие требования к payload}

С целью значительного усложнения  выявления алгоритма payload
необходимо реализовать:

\begin{enumerate}
\item{Получение payload через скрытый канал в зашифрованном виде\footnote{поток данных в скрытом канале
зашифровывается в штатном порядке, то есть ключ и payload будут зашифрованы дважды, но это не
существенно - так проще для единообразия}}
\item{Получение данных для работы payload с сервера через скрытый канал в зашифрованном виде}
\item{Получение ключа для расшифровки payload через скрытый канал в зашифрованном виде}
\item{Получение отдельного ключа для расшифровки данных для работы payload через скрытый
канал в зашифрованном виде}
\item{хранение payload и ключа его расшифровки только в памяти без записи на диск}
\item{минимизация количества инструкций payload хранимых в расшифрованном виде}
\item{ротация ключей шифрования на сервере раз в сутки или чаще
 \footnote {
 поскольку payload для большинства закладок одинаков - ротация на
 сервере даже раз в час не должна быть существенной проблемой с точки
 зрения ресурсоемкости
  }
}
\item{хранение внутри закладки информации о конфигурации компьютера на момент исполнения с отрабаткой
ситуаций по перемещению на другой ПК как нештатной.}
\end{enumerate}


\subsubsection{Общие требования к данным для payload}
\label{in_mem_only_payload}
Если payload подразумевает получение данных для произведения операций
над данными носителя, например, для поиска по ключевым словам, то  эти
данные надо хранить, во первых, исключительно в памяти ОС, а во вторых
их крайне желательно зашифровывать на отдельном ключе, который
получается  с сервера и также хранится только в памяти. На том же ключе
должны быть  зашифрованы промежуточные данные получаемые при обработке
данных на основе информации получаемой с сервера. Если payload
потребуется хранить, например, копии файлов пользователя, то они должны
быть зашифрованы на отдельном ключе, отличном от текущего для
зашифрования/расшифрования самого payload и его  временных данных.
Назовем такой <<ключ хранения>>. Использование ключа хранения с ротацией
<<on-demand>>\footnote{то есть должна производиться ротация ключей:
например раз в день ключ должен меняться}.\\
Способ хранения payload только в памяти также известен как <<anti-forensics>>.

\paragraph{Преимущества данного подхода}
\begin{itemize}
\item{ Использование in memory only хранения payload и ключа его расшифрования
позволит значительно затруднить реверсинг, а также позволит выдавать ложную
информацию о задачах которые были поставлены закладке, если реверсирующая
сторона была обнаружена. Более того, при использовании получения ключа для
расшифровки исполняемого кода и данных с сервера возникает гораздо больше
узловых точек, в которых реверсер может обнаружить свое присутствие в силу
несоблюдения протокола обмена данными, в первую очередь - по временным параметрам}
\item{
 Использование ротируемых ключей хранения позволит избежать раскрытия объемов
 утечки информации с носителя rootkit, поскольку, после того как файл признан
 необходимым к хранению очень мало возможных ситуаций, когда для владельца rootkit
 будет осмысленным его расшифрование на клиенте вместо отправки файла на сервер и
 дальнейшей обработки локально, в безопасных условиях, когда нет необходимости
 прятать свои действия от пользователя и проверяющего ПО.
}
\end{itemize}

\subsubsection{Реализация шифрования}

\paragraph{Шифрование сетевого трафика\\}
Некоторые компании имеют маленький интернет трафик и делают полное
журналирование работы с интернет за день и, возможно, более. Для того
чтобы исключить расшифровку трафика обмена с сервером для любой закладки
за счет утечки ключа полученного реверсингом одной закладки необходимо
реализовать:

\begin{itemize}
\item{индивидуальность сеансового ключа для каждой закладки}
\item{алгоритм смены сеансового ключа}
\end{itemize}

Это позволит исключить возможность составления сигнатур для IDS с целью
их дальнейшего использования для обнаружения установленных закладок в
других местах.\\

При этом однако необходимо учитывать проблему старых ключей, например, клиент был выключен
на время отпуска или выходные, если ротация ключей уже произошла - такого клиента необходимо
 либо игнорировать, либо, например, переводить обратно в режим инкубационного периода. В
некоторых случаях будет иметь смысл прогон такого клиента на дополнительных проверках и понижение
индекса доверия со стороны управляющего сервера.

\paragraph{Сеансовый ключ.\\}

Под сеансовым ключом понимается ключ используемый для
зашифрования/расшифрования в транспортном протоколе поверх скрытого
канала\footnote{в случае с рассматривавшимся выше скрытым каналом в jpeg
картинках это ключ которым расшифровывается область данных содержащая
блок данных транспортного протокола(что мы прячем в транспортном
протоколе - набор команд боту или набор данных для последующей
дообработки - в данном случае не важно.)}

\paragraph{использование нескольких алгоритмов шифрования\\}
Первичный запуск должен использовать bruteforce схему, payload должен быть зашифрован с использованием стойких алгоритмов с длиннами ключей не поддающимися bruteforce в
разумные сроки (сто и более лет). См. также \ref{random_enc_key} на стр.
 \pageref{random_enc_key} и \ref{decryptor_as_a_part_of_key} на стр. \pageref{decryptor_as_a_part_of_key}.

\subsection{Реакция}
\subsubsection{Удачность периода}

Окончательные выводы о любом периоде в процессе которого идет обмен
данными с сервером, должны осуществляться сервером.
Разумеется, если в инкубационном периоде закладка не проявляет
 сетевой активности -  у сервера просто нет данных для выявления
 его  удачности или неудачности.

Поскольку сервер отдает обновления для каждой ступени, то по факту
обнаружения несоблюдения алгоритма он может:
\begin{itemize}
\item{зарегистрировать во внутренней базе данных информацию о характеристиках противодействующей стороны - IP,OS,идентификаторы железа, уникальный идентификатор пойманной закладки и прочее}
\item {выдавать различные файлы с
мусором вместо зашифрованных данных в области картинки реализующей
скрытый транспортный протокол передачи данных (только если нет средств
проверки валидности данного типа данных на закладке, иначе передача мусора
будет говорить о том, что сервер обнаружил противодействие).}
\item{выдать payload не соответствующий реальному использованию остальных закладок, т.е. фактически
 скормить любой алгоритм, в следовании которому данного типа закладок
 надо убедить реверсера/автоматическую систему анализа malware.}
\item{блокировать обмен данными с закладкой на уровне сети или на уровне протокола в рамках ботнета}

\end{itemize}

\subsubsection{Варианты реакции на обнаружение хонипота}

В случае запуска в сандбоксе основная задача - сдетектить и отстучать на C\&C для внесения в базу очередного хонипота.


\paragraph{Возможности:\\}
Возможны различные варианты ответов на выявление неудачности каждого из
периодов. Их гораздо больше чем описанных здесь, но по мнению авторов
наиболее разумным является следующее поведение:

\begin{itemize}
\item{Выявление хонипота на момент инкубационного периода должно
повлечь, в первую очередь,  попытку отправки информации о нем на
сервер. Отправку информации желательно организовать одновременно  по
нескольким каналам, например smptp(email)/http/https/dns, как минимум
 двум}

\item{Выявление хонипота в тестовом режиме на мой взгляд, должно
повлечь выдачу на хост заведомо неправильного бинарника, а если
точнее - бинарника с совсем другими, почти безобидными функциями.}

\item{Выявление хонипота в рабочем режиме должно повлечь за собой
 блокирование работы с данной закладкой - в нормальной ситуации
 хонипот должен быть обнаружен на более ранних этапах.}
\end{itemize}

Следует также по разному отрабатывать хонипот и реверсинг. В частности, при обнаружении
реверсинга закладки желательно инициировать смену части ключей используемых в ботнете.

\subparagraph{Реакция на обнаружене в инкубационном периоде:}
Неплохо было бы использование dns туннеля в числе прочих методов.
Есть немалая вероятность того, что DNS трафик, который по сути своей
деструктивным быть почти не может (кроме попыток DoS), не будет
запрещаться, или перенаправляться.

\subparagraph{Реакция на обнаружение в тестовом периоде:}
В зависимости от этапа выявления алгоритма по бинарю, на котором
находится реверсер,он может знать определенную часть общей схемы. Так
если выявлено, что закладка находится в тестовом режиме, то можно
предположить, что реверсер уже выявил в ней возможности класса
<<download and execute>> используемые для обновления. Разумно в таком
случае отдать реверсеру какую нибудь  безобидную закладку, которая не
будет делать ничего особенно неприятного, а например, всего лишь,
рапортовать список установленного в системе ПО на какой нибудь сервер.
Однако это подразумевает поддержку дополнительного сервера и другого протокола
обмена между закладками и сервером (чтобы не вызывать подозрений), и,
таким образом, может быть слишком накладным. Поэтому более подходящим
может оказаться просто блокирование работы с пойманной закладкой, хотя вариант с
выдачей некоего <<левого>> payload гораздо вероятнее приведет на
противодействующей стороне к решению, что закладка уже достаточно изучена и
дальнейшее исследование можно прекратить.

\subparagraph{Реакция на обнаружение в рабочем режиме:\\}
Обнаружение хонипота в рабочем режиме, а не ранее может говорить о том,
что часть алгоритма работы ботнета раскрыта, так что этот вариант надо отрабатывать
особым образом.


\paragraph{База данных клиентов\\}
Основываясь на вышеуказанном сервер контролирующий закладку должен вести
базу данных по железу  на котором исполняется закладка. На  основании
имеющейся базы данных и ряда проверок сервер\footnote{не клиент!} сможет
определить\footnote{например используя повторяемость ситуации} с
достаточно высокой вероятностью имеет ли он дело с honeypot,
реверсером энтузиастом, профессиональным реверсер или же с нормальным
пользователем.

%По окончании инкубационного периода закладка должна запросить на сервере очередной морф
